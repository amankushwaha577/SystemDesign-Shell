<!-- 
3. Event-Driven Model :
-----------------------
The Event-Driven Model is an asynchronous communication pattern.
where services communicate by emitting and responding to events instead of directly calling each other. 

Note : Events are generated when a change occurs, and other services react to these events without needing to know their source service.

Note : The sender and receiver service do not directly communicate with each other, 
       they don't know about each other,
       making the system loosely coupled and scalable.

Workflow:
--------
1. An event occurs : A user action, system change, or an external trigger (e.g., "Order Placed").
                     The event is sent to an Event Bus.
2. Event Bus (Kafka / RabbitMQ / AWS EventBridge) receives the event.
3. Subscribers listen to the event â€“ Multiple services can consume the event and take independent actions.

Note : Services react asynchronously â€“ Services process the event without blocking each other.

                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚  Event Source â”‚  (User Action, Sensor, API)
                              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                              (1) Generates Event  
                                    â”‚
                                    â–¼
                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                           â”‚   Event Broker   â”‚  (Kafka, RabbitMQ, Redis Streams)
                           â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                           (2) Routes Event to Consumers
                                 â”‚
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚                 â”‚
                     â”Œâ”€â”€â–¼â”€â”€â”ðŸ—‚ï¸+ðŸ“š   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”ðŸ—‚ï¸+ðŸ“š  
                     â”‚Svc 1â”‚         â”‚  Svc 2  â”‚    <-- Acts as an Event Producer
                     â””â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                                          â”‚
                                 (3) Produces New Event
                                          â”‚
                                          â–¼
                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                           â”‚  Event Broker 2  â”‚  (Chained Event Processing)
                           â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                           (4) Routes to More Consumers
                                 â”‚
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚                 â”‚
                     â”Œâ”€â”€â–¼â”€â”€â”ðŸ—‚ï¸+ðŸ“š   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”ðŸ—‚ï¸+ðŸ“š <------ ðŸ—‚ï¸ (Data of Service) + ðŸ“š ( Data of Event ) 
                     â”‚Svc 3â”‚         â”‚  Svc 4  â”‚       So we are saving data of own + data coming from another service
                     â””â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     (5) Processes Event and Stores Data



Main Advantage of EVent-Driven Model :
------------------------------------
1. âœ… Great "Consistency" :
   When any service gets event from event Bus it save this event in its own DB.
   So we are saving our data + incoming event data of other service.
   SO suppose any damage happen to sender service we don't care about it.
   Or Any change happen in sender service DB we don't care about it.

2. âœ… Decoupled & Scalable :
   Services donâ€™t depend on each other directly.

3. âœ… Event Replay & History :
   Events can be stored and replayed if needed.

4. âœ… Highly Responsive â€“ Services react instantly to events.
5. âœ… Transaction Guaranteed : Either 0/1


Disadvantages:
--------------
1. âŒ Event Ordering Complexity â€“ Handling event sequence across services can be tricky.
2. âŒ Difficult Debugging â€“ Hard to track event flow when multiple services are involved.
3. âŒ Too much resource consumption â€“ Requires an event bus, queue, handlers, High CPU usage and event processing logic.
4. âŒ latency - Decoupled nature of event-driven system means that there is multiple layer of communication
                which can introduce latency.
5. âŒ If we want to restrict some service to consume evevnts - Than we need another level of implementation for restiction
                                                                It's difficult.  

Best Use Cases:
1. Real-time data processing.
2. Microservices communication.
3. IoT and sensor-driven applications.
-->
                                                                

<!-- 
Event-driven => Publish event when someone needs to know something. SO they pulish events.
Req/Response => Service ask for something (May be for data or something) 

Event-driven Model also uses Pubsher/Subscriber Model.
-->