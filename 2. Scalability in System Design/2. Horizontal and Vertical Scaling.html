<!-- 
1. Horizontal Scaling (Scaling Out)
    a. Approach: Adds more machines (nodes/servers) to distribute the load.
    b. Common Use Cases: Distributed systems, cloud computing (e.g., AWS Auto Scaling, Kubernetes, Microservices).
    c. Data Storage: Often uses distributed databases (e.g., Cassandra, MongoDB, DynamoDB).
    c. Communication Model: Network-based communication (requests between distributed nodes).

✅ Advantages:
    a. High Resilience ✅: If one server fails, others handle the load (fault tolerance).
    b. High Scalability ✅: More servers can be added dynamically.
    c. No Single Point of Failure ✅: Redundancy ensures high availability.

❌ Disadvantages:
    a. Data Consistency Issues ❌: Since data is spread across multiple nodes, ensuring strong consistency is difficult 
                                   (eventual consistency is often used).
                                   Ex : If operation has to be atomic we need to lock all the servers & DB that we are using for
                                        that operation.
    b. Complexity ❌: Requires load balancing, distributed coordination, and replication management.
    c. Synchronization Overhead in DB ( High Latency ) ❌: Requires distributed database techniques like replication, sharding, and quorum-based updates.


2. Vertical Scaling (Scaling Up) 
    a. Approach: Increases the resources (CPU, RAM, disk) of a single machine.
    b. Common Use Cases: Monolithic applications, relational databases (e.g., MySQL, PostgreSQL).
    c. Data Storage: Uses a single-node database for consistency.

✅ Advantages:
    a. Strong Data Consistency ✅: Since all operations happen on the same machine, maintaining ACID (Atomicity, Consistency, Isolation, Durability) properties is easier.
    b. Lower Complexity ✅: No need for Load balancing, distributed coordination or data replication.
    c. Low Latency ✅: Faster data access as everything is on one machine.

❌ Disadvantages:
    a. Low Resilience ❌: If the machine fails, everything goes down (single point of failure).
    b. Limited Scalability ❌: Hardware has a physical limit (cannot scale infinitely | cant make system too bigger ).
    c. Downtime Risk ❌: Upgrading the machine may require system restarts.
-->

<!-- 
Horizontal Scaling Communication
    a. Uses network-based protocols like HTTP, gRPC, WebSockets, or Message Queues (RabbitMQ, Kafka) for inter-node communication.
       Example: In a microservices architecture, services communicate via REST APIs or gRPC.
    b. Database Communication:
       a. Uses distributed databases (e.g., Cassandra, DynamoDB, MongoDB).
       b. Read/write operations may require consensus algorithms like Paxos or Raft.
       c. Eventual consistency is common due to network delays.

Vertical Scaling Communication
    a. Uses in-memory communication between processes.
       Example: A monolithic application where function calls or database queries happen within the same server.
    b. Database Communication:
       a. Uses single-node databases like MySQL or PostgreSQL.
       b. Ensures strong consistency (all read/write operations are immediately visible).
       c. Faster queries since there's no network overhead.
-->

