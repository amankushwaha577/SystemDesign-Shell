<!-- 
Horizontal Scaling (Scaling Out) vs 2. Vertical Scaling (Scaling Up) 
    a. Approach: 
       In Horizontal Scaling we Add more machines (nodes/servers) to distribute the load.
       In Vertical Scaling we add more resources (CPU, RAM, disk) in a single machine.
   
    b. Data Storage: 
       Horizontal scaling uses   distributed databases (e.g., Cassandra, MongoDB).
           -> Read/write operations may require Time taking algorithms like Paxos or Raft. 
       Vertical Scaling   Uses a single-node database for Good consistency ( MySQL or PostgreSQL ) .
           -> All read/write operations are immediately visible because of single DB.

    c. Communication Model: 
       Horizonatal Scaling uses Network-based protocols to talk with nodes. (Protocols like HTTP, gRPC, WebSockets, or Message Queues (RabbitMQ, Kafka))
       Vertical Scaling uses In-memory communication to talk within the same machine. (function calls)

    b. Common Use Cases: 
       Horizontal Scaling is used in Distributed systems, cloud computing (e.g., Kubernetes, Microservices, AWS Auto Scaling ).
       Vertical Scaling  is used  in Monolithic applications, relational databases (e.g., MySQL, PostgreSQL).

1. Horizontal Scaling :
✅ Advantages:
    a. High Resilience ✅: If one server fails, others handle the load (fault tolerance).
    b. High Scalability ✅: More servers can be added dynamically.
    c. No Single Point of Failure ✅: Redundancy of nodes ensures high availability.

❌ Disadvantages:
    a. Data Consistency Issues ❌: Since data is spread across multiple nodes, ensuring strong consistency is difficult 
                                   (eventual consistency is often used).
                                   Ex : If operation has to be atomic we need to lock all the servers & DB that we are using for
                                        that operation.
    b. Complexity ❌: Requires load balancing, 
                               distributed nodes coordination, and 
                               replication management.
    c. Overhead in DB ( High Latency ) ❌: Requires distributed database techniques like replication, sharding, and quorum-based updates.


2. Vertical Scaling :
✅ Advantages:
    a. Strong Data Consistency ✅: Since all operations happen on the same machine, maintaining ACID (Atomicity, Consistency, Isolation, Durability) properties is easier.
    b. Lower Complexity ✅: No need for Load balancing, distributed coordination or data replication.
    c. Low Latency ✅: Faster data access as everything is on one machine.

❌ Disadvantages:
    a. Low Resilience ❌: If the machine fails, everything goes down (single point of failure).
    b. Limited Scalability ❌: Hardware has a physical limit (cannot scale infinitely | cant make system too bigger ).
    c. Downtime Risk ❌: Upgrading the machine may require system restarts.
-->
