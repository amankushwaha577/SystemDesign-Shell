<!-- 
1. Horizontal Scaling (Scaling Out)
    a. Approach: 
       In Horizontal Scaling we Add more machines (nodes/servers) to distribute the load.
       In Vertical Scaling we add more resources (CPU, RAM, disk) in a single machine.
   
    b. Data Storage: 
       Horizontal scaling uses   distributed databases (e.g., Cassandra, MongoDB).
       Vertical Scaling   Uses a single-node database for Good consistency ( MySQL or PostgreSQL ) .

    c. Communication Model: 
       Horizonatal Scaling uses Network-based communication to talk with nodes. (Protocols like HTTP, gRPC, WebSockets, or Message Queues (RabbitMQ, Kafka))
       Vertical Scaling uses In-memory communication to talk within the same machine. (function calls)

    b. Common Use Cases: 
       Horizontal Scaling is used in Distributed systems, cloud computing (e.g., Kubernetes, Microservices, AWS Auto Scaling ).
       Vertical Scaling  is used  in Monolithic applications, relational databases (e.g., MySQL, PostgreSQL).

✅ Advantages:
    a. High Resilience ✅: If one server fails, others handle the load (fault tolerance).
    b. High Scalability ✅: More servers can be added dynamically.
    c. No Single Point of Failure ✅: Redundancy of nodes ensures high availability.

❌ Disadvantages:
    a. Data Consistency Issues ❌: Since data is spread across multiple nodes, ensuring strong consistency is difficult 
                                   (eventual consistency is often used).
                                   Ex : If operation has to be atomic we need to lock all the servers & DB that we are using for
                                        that operation.
    b. Complexity ❌: Requires load balancing, 
                               distributed nodes coordination, and 
                               replication management.
    c. Overhead in DB ( High Latency ) ❌: Requires distributed database techniques like replication, sharding, and quorum-based updates.


2. Vertical Scaling (Scaling Up) 
    
✅ Advantages:
    a. Strong Data Consistency ✅: Since all operations happen on the same machine, maintaining ACID (Atomicity, Consistency, Isolation, Durability) properties is easier.
    b. Lower Complexity ✅: No need for Load balancing, distributed coordination or data replication.
    c. Low Latency ✅: Faster data access as everything is on one machine.

❌ Disadvantages:
    a. Low Resilience ❌: If the machine fails, everything goes down (single point of failure).
    b. Limited Scalability ❌: Hardware has a physical limit (cannot scale infinitely | cant make system too bigger ).
    c. Downtime Risk ❌: Upgrading the machine may require system restarts.
-->

<!-- 
Horizontal Scaling Communication
    a. Uses network-based protocols like HTTP, gRPC, WebSockets, or Message Queues (RabbitMQ, Kafka) for inter-node communication.
       Example: In a microservices architecture, services communicate via REST APIs or gRPC.
    b. Database Communication:
       a. Uses distributed databases (e.g., Cassandra, DynamoDB, MongoDB).
       b. Read/write operations may require consensus algorithms like Paxos or Raft.
       c. Eventual consistency is common due to network delays.

Vertical Scaling Communication
    a. Uses in-memory communication between processes.
       Example: A monolithic application where function calls or database queries happen within the same server.
    b. Database Communication:
       a. Uses single-node databases like MySQL or PostgreSQL.
       b. Ensures strong consistency (all read/write operations are immediately visible).
       c. Faster queries since there's no network overhead.
-->

