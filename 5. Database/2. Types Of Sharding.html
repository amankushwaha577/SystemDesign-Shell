<!--  
Types of Sharding ðŸš€  

Sharding can be implemented in different ways depending on how data is distributed across shards. The most common types of sharding are:  

1. Horizontal Sharding (Scaling) :
---------------------------------
Data is split by rows/range, storing different types of data in different shards.  

ðŸ“Œ Example:  
    a. Stores all users and their posts in one database.  
    b. As the number of users increases, **queries become slow**.  

    users_table (Before Sharding)  
    | user_id | username | email          | profile_pic       | content         | likes | comments |
    |---------|---------|---------------|------------------|----------------|-------|----------|
    | 1       | JohnDoe  | john@email.com | john_pic.jpg     | "Hello World!"  | 25    | 5        |
    | 2       | Alice99  | alice@mail.com | alice_pic.jpg    | "My first post" | 30    | 8        |
    | 3       | Mike21   | mike@mail.com  | mike_pic.jpg     | "Nice weather"  | 20    | 3        |
    | 4       | EmmaK    | emma@mail.com  | emma_pic.jpg     | "Love this!"    | 50    | 10       |

ðŸ”´ Problems with a Single Database:  
-----------------------------------
    a. ðŸš¨ **Too many users** slow down the database.  
    b. ðŸš€ **Hard to scale** because all users are stored in one place.  
    c. âŒ **More downtime** if the database becomes overloaded.  

âœ… After Horizontal Sharding (Users Distributed Across Multiple Databases) :

    ðŸŸ¢ Shard 1 (users_db_1) - Stores users with user_id 1 to 2
    | user_id | username | email          | profile_pic       |
    |---------|---------|---------------|------------------|
    | 1       | JohnDoe  | john@email.com | john_pic.jpg     |
    | 2       | Alice99  | alice@mail.com | alice_pic.jpg    |

    ðŸŸ¢ Shard 2 (users_db_2) - Stores users with user_id 3 to 4 
    | user_id | username | email         | profile_pic       |
    |---------|---------|--------------|------------------|
    | 3       | Mike21  | mike@mail.com  | mike_pic.jpg     |
    | 4       | EmmaK   | emma@mail.com  | emma_pic.jpg     |

    ðŸŸ¢ Shard 1 (posts_db_1) - Stores posts for users 1 to 2 
    | post_id | user_id | content         | likes | comments |
    |---------|---------|----------------|-------|----------|
    | 101     | 1       | "Hello World!"  | 25    | 5        |
    | 102     | 2       | "My first post" | 30    | 8        |

    ðŸŸ¢ Shard 2 (posts_db_2) - Stores posts for users 3 to 4 
    | post_id | user_id | content         | likes | comments |
    |---------|---------|----------------|-------|----------|
    | 103     | 3       | "Nice weather"  | 20    | 3        |
    | 104     | 4       | "Love this!"    | 50    | 10       |

âœ… **Advantages of Horizontal Sharding:**  
----------------------------------------  
ðŸ”¹ **Better Load Distribution** â€“ Queries are divided across multiple databases.  
ðŸ”¹ **Improved Performance** â€“ Each database has **fewer rows**, making lookups faster.  
ðŸ”¹ **Easy Scalability** â€“ More shards can be added as the user base grows.  
ðŸ”¹ **Less Downtime** â€“ If one shard fails, others still function normally.  
-->



<!--  
2. Vertical Sharding  :
---------------------- 
ðŸ”¹ How It Works:  
   Data is split by feature/column, storing different types of data in different shards.  

ðŸ“Œ Example:  
    a. User profiles stored in one database.  
    b. Post stored in another database.

    users_table (Before Sharding) -
    | user_id | username | email          | profile_pic       | content         | likes | comments |
    |---------|---------|---------------|------------------|----------------|-------|----------|
    | 1       | JohnDoe  | john@email.com | john_pic.jpg     | "Hello World!"  | 25    | 5        |
    | 2       | Alice99  | alice@mail.com | alice_pic.jpg    | "My first post" | 30    | 8        |

ðŸ”´ Problems with a Single Database: 
-----------------------------------
    a. As posts increase, **queries become slower**.  
    b. User data and posts are mixed , **making it inefficient to scale**.  
    c. Harder to cache **frequently accessed user data** separately. 

    Shard1 : users_table - 
    | user_id | username | email          | profile_pic       |
    |---------|---------|---------------|------------------|
    | 1       | JohnDoe  | john@email.com | john_pic.jpg     |
    | 2       | Alice99  | alice@mail.com | alice_pic.jpg    |

    SHard2 : posts_table -
    | post_id | user_id | content         | likes | comments |
    |---------|---------|----------------|-------|----------|
    | 101     | 1       | "Hello World!"  | 25    | 5        |
    | 102     | 2       | "My first post" | 30    | 8        |

âœ… Advantages of Vertical Sharding:  
------------------------------------
a. **Faster Queries** â€“ User-related queries donâ€™t mix with post-related queries.  
b. **Scalability** â€“ Posts database can be scaled separately.  
c.  **Efficient Caching** â€“ Frequently accessed user data can be cached separately.
-->
 


<!--  
3. Hash-Based Sharding  
ðŸ”¹ How It Works:  
- A hash function is used to distribute data evenly across shards.  
- The hash function takes a key (e.g., user_id) and maps it to a shard.  

ðŸ“Œ Example:  
shard_id = hash(user_id) % total_shards  
- User with user_id = 101 goes to Shard 1  
- User with user_id = 202 goes to Shard 2  

âœ… Pros:  
- Even data distribution, preventing hotspots.  
- Scalable for large systems with unpredictable access patterns.  

âŒ Cons:  
- Adding new shards requires resharding (recalculating hash mappings).  
- Hard to perform range queries efficiently.  

4. Directory-Based Sharding  
ðŸ”¹ How It Works:  
- Uses a lookup table (metadata store) to map records to specific shards.  

ðŸ“Œ Example:  
- A mapping table keeps track of which shard contains which user.  
  | user_id | shard_id |  
  |---------|---------|  
  | 101     | Shard 1 |  
  | 202     | Shard 2 |  

- Application queries the directory first to find the correct shard.  

âœ… Pros:  
- Flexible and allows dynamic shard management.  
- Easy to add or remove shards without massive data migration.  

âŒ Cons:  
- The lookup table is a single point of failure if not replicated properly.  
- Adds an extra lookup step for each query, increasing latency.  

Comparison of Sharding Types  

| Sharding Type       | Pros | Cons | Best For |  
|---------------------|------|------|----------|  
| Range-Based        | Simple, good for range queries | Hotspots if data is unevenly distributed | Ordered datasets (e.g., time-series data) |  
| Vertical           | Optimized storage for different data types | Limited scalability, complex joins | Multi-feature applications (e.g., social networks) |  
| Hash-Based         | Even load distribution, no hotspots | Hard to do range queries, costly resharding | Large-scale applications (e.g., e-commerce, social media) |  
| Directory-Based    | Flexible, easy to add shards | Extra lookup overhead, risk of failure | Dynamic scaling environments |  

Which Sharding Type Should You Use?  
âœ… Use Range-Based Sharding if you need efficient range queries and sequential data access.  
âœ… Use Vertical Sharding if your data is naturally divided into separate features (e.g., user profiles vs. transactions).  
âœ… Use Hash-Based Sharding if you want even load distribution and random access patterns.  
âœ… Use Directory-Based Sharding if your system needs dynamic scalability with flexible shard management.  

Would you like an example implementation in MongoDB, MySQL, or PostgreSQL? ðŸš€  
-->
