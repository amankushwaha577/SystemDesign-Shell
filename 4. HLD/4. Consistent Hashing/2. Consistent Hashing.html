<!-- 
In Consistent Hashing we hashes both request and server with same hashing function in same range of values.
    [ server_index where server will go = hash(serverId)  % M ]
    [ key_index   where request will go = hash(requestId) % M ]

    M = we use a circular hash space (0 to 2³² - 1)
    Hash function = SHA-1, MurmurHash.
-->

<!--
    let M= 30 (Size of Ring)

    Step 1: Map Severs on Ring using Same Hash Function :
    🟠 server 0  s0  | Id- 0  =>  Server_Index = hash(s1) % 30 =  hash(0) % 30  = 49 % 30  =>  23
    🟠 server 1  s1  | Id- 1  =>  Server_Index = hash(s2) % 30 =  hash(1) % 30  = 67 % 30  =>  10
    🟠 server 2  s2  | Id- 2  =>  Server_Index = hash(s3) % 30 =  hash(2) % 30  = 72 % 30  =>  25
    🟠 server 3  s3  | Id- 3  =>  Server_Index = hash(s3) % 30 =  hash(3) % 30  = 12 % 30  =>  29

    Step 2: Map Requests on Ring using Same Hash Function:
    🔵 Request 0  r0  | Id- 0  =>  Request_Index = hash(r0) % 30 =  hash(0) % 30  = 0 % 30  =>  0
    🔵 Request 1  r1  | Id- 1  =>  Request_Index = hash(r1) % 30 =  hash(1) % 30  = 1 % 30  =>  1 
    🔵 Request 2  r2  | Id- 2  =>  Request_Index = hash(r2) % 30 =  hash(2) % 30  = 2 % 30  =>  2 
    🔵 Request 3  r3  | Id-26  =>  Request_Index = hash(r2) % 30 =  hash(26) % 30 = 26 % 30 =>  26

        r0       r1
         🔵──────🔵───🔵 r2          ---
         /                \               \
  (29)s4🔴                  \              \
      /                   🔴 s2 (10)        |
      |                     |                | -> Clockwise Direction  Mapping
 r3 🔵                     🔵 r4
      \                     |
       \                   /
         \               /
      s3 🔴───────────🔴 s1 (23)   || Consistent Hashing Ring
     (25)

    Step 3: Every Request will take its nearest server in clockwise direction for load balancing.
            r0, r1, r2 -> s2 🔴
            r4         -> s1 🔴
            r3         -> s4 🔴

     There is no load on s3 🔴


Advantage Of Consistent Hashing :
--------------------------------
1. With simple hashing, when a new server is added, almost all the requests need to be remapped.
   With consistent hashing, adding a new server only requires redistribution of a fraction of the requests.

   Suppose a new server s5 is added.
   The new server will take responsibility for some keys from its successor server, reducing load imbalance.

        r0     s5   r1
         🔵───🔴──🔵───🔵 r2         
         /                \               
  (29)s4🔴                  \              
      /                   🔴 s2 (10)        
      |                     |               
 r3 🔵                     🔵 r4
      \                     |
       \                   /
         \               /
      s3 🔴───────────🔴 s1 (23)   
     (25)

            r0         -> s5 🔴  ( New Request alignment)

            --  r1, r2 -> s2 🔴  ( Unaffected : Request alignment)
            r4         -> s1 🔴  ( Unaffected : Request alignment)
            r3         -> s4 🔴  ( Unaffected : Request alignment)
      There is no load on s3 🔴  ( Unaffected : Request alignment)

           
            
      

2. If a node fails, its keys are reassigned to the next available node, reducing rehashing to only a fraction of the keys.

        r0     s5   r1
         🔵───🔴──🔵───🔵 r2         
         /                \               
  (29)s4🔴                  \              
      /                     ❌ ------------------- > 🔴 s2 (10)  Failed Server  
      |                     |               
 r3 🔵                     🔵 r4
      \                     |
       \                   /
         \               /
      s3 🔴───────────🔴 s1 (23)   
     (25)

            r1, r2     -> s1 🔴  ( New Request alignment)
            r4         -> s1 🔴  ( Unaffected : Request alignment)

            r3         -> s4 🔴  ( Unaffected : Request alignment)
            r0         -> s5 🔴  ( Unaffected : Request alignment)
      There is no load on s3 🔴  ( Unaffected : Request alignment)
-->
